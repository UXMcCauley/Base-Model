// src/app/actions.ts
'use server';

import { mainAgent, MainAgentInput, MainAgentOutput } from '@/ai/flows/main-agent';
import { hrAgent, HrAgentInput, HrAgentOutput } from '@/ai/flows/hr-agent';
import { workforceAgent, WorkforceAgentInput, WorkforceAgentOutput } from '@/ai/flows/workforce-agent';
import { summarizeEmail, SummarizeEmailInput, SummarizeEmailOutput } from '@/ai/flows/summarize-email';
import { generateSpreadsheet, GenerateSpreadsheetInput, GenerateSpreadsheetOutput } from '@/ai/flows/generate-spreadsheet';
import { z } from 'zod';

export interface AgentResponse {
  id: string;
  userQuery: string;
  type: 'text' | 'csv' | 'documentOutline' | 'error' | 'loading';
  content: string;
  filename?: string;
  error?: string;
}

const querySchema = z.object({
  query: z.string().min(1, "Query cannot be empty."),
});

export async function processUserQuery(prevState: AgentResponse | null, formData: FormData): Promise<AgentResponse> {
  const rawQuery = formData.get('query');
  const validatedQuery = querySchema.safeParse({ query: rawQuery });

  const uniqueId = Date.now().toString();

  if (!validatedQuery.success) {
    return {
      id: uniqueId,
      userQuery: typeof rawQuery === 'string' ? rawQuery : '',
      type: 'error',
      content: validatedQuery.error.errors.map(e => e.message).join(', '),
      error: validatedQuery.error.errors.map(e => e.message).join(', '),
    };
  }

  const userQuery = validatedQuery.data.query;

  try {
    // Step 1: Call the main agent to determine action type
    const mainAgentInput: MainAgentInput = { query: userQuery };
    const mainAgentDecision = await mainAgent(mainAgentInput);

    // Step 2: Based on decision, call the appropriate specialized agent or return general response
    switch (mainAgentDecision.actionType) {
      case 'hr':
        const hrInput: HrAgentInput = { query: mainAgentDecision.processedQuery };
        const hrOutput = await hrAgent(hrInput);
        return {
          id: uniqueId,
          userQuery,
          type: 'text',
          content: hrOutput.answer,
        };
      case 'workforce':
        const wfInput: WorkforceAgentInput = { query: mainAgentDecision.processedQuery };
        const wfOutput = await workforceAgent(wfInput);
        return {
          id: uniqueId,
          userQuery,
          type: 'text',
          content: wfOutput.response,
        };
      case 'summarize_email':
        // This case assumes mainAgentPrompt would have made processedQuery the email content
        // or mainAgentDecision.actionType would be 'general_response' to ask for content.
        // If mainAgent returns 'summarize_email', it means it found the email content.
        const emailInput: SummarizeEmailInput = { emailContent: mainAgentDecision.processedQuery };
        const summaryOutput = await summarizeEmail(emailInput);
        return {
          id: uniqueId,
          userQuery,
          type: 'text',
          content: `Summary: ${summaryOutput.summary}`,
        };
      case 'generate_spreadsheet':
        const ssInput: GenerateSpreadsheetInput = { description: mainAgentDecision.processedQuery };
        const ssOutput = await generateSpreadsheet(ssInput);
        return {
          id: uniqueId,
          userQuery,
          type: 'csv',
          content: ssOutput.spreadsheetData,
          filename: mainAgentDecision.filename || 'spreadsheet.csv',
        };
      case 'generate_document_outline':
         // For document outline, we'll treat it as text content for now.
         // The prompt for mainAgent should ensure processedQuery is the outline.
        return {
          id: uniqueId,
          userQuery,
          type: 'documentOutline',
          content: mainAgentDecision.processedQuery, // This should be the outline generated by the mainAgent's prompt logic
          filename: mainAgentDecision.filename || 'document_outline.txt',
        };
      case 'general_response':
      default:
        return {
          id: uniqueId,
          userQuery,
          type: 'text',
          content: mainAgentDecision.processedQuery,
        };
    }
  } catch (error) {
    console.error("Error processing query:", error);
    return {
      id: uniqueId,
      userQuery,
      type: 'error',
      content: error instanceof Error ? error.message : 'An unexpected error occurred.',
      error: error instanceof Error ? error.message : 'An unexpected error occurred.',
    };
  }
}
